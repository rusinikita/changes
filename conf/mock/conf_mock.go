// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"sync"
)

// Ensure, that ConfMock does implement Conf.
// If this is not the case, regenerate this file with moq.
var _ Conf = &ConfMock{}

// ConfMock is a mock implementation of Conf.
//
//	func TestSomethingThatUsesConf(t *testing.T) {
//
//		// make and configure a mocked Conf
//		mockedConf := &ConfMock{
//			GetStringFunc: func(key string, defaultValue ...string) string {
//				panic("mock out the GetString method")
//			},
//			UnmarshalFunc: func(key string, config any, defaultValue ...any) error {
//				panic("mock out the Unmarshal method")
//			},
//		}
//
//		// use mockedConf in code that requires Conf
//		// and then make assertions.
//
//	}
type ConfMock struct {
	// GetStringFunc mocks the GetString method.
	GetStringFunc func(key string, defaultValue ...string) string

	// UnmarshalFunc mocks the Unmarshal method.
	UnmarshalFunc func(key string, config any, defaultValue ...any) error

	// calls tracks calls to the methods.
	calls struct {
		// GetString holds details about calls to the GetString method.
		GetString []struct {
			// Key is the key argument value.
			Key string
			// DefaultValue is the defaultValue argument value.
			DefaultValue []string
		}
		// Unmarshal holds details about calls to the Unmarshal method.
		Unmarshal []struct {
			// Key is the key argument value.
			Key string
			// Config is the config argument value.
			Config any
			// DefaultValue is the defaultValue argument value.
			DefaultValue []any
		}
	}
	lockGetString sync.RWMutex
	lockUnmarshal sync.RWMutex
}

// GetString calls GetStringFunc.
func (mock *ConfMock) GetString(key string, defaultValue ...string) string {
	callInfo := struct {
		Key          string
		DefaultValue []string
	}{
		Key:          key,
		DefaultValue: defaultValue,
	}
	mock.lockGetString.Lock()
	mock.calls.GetString = append(mock.calls.GetString, callInfo)
	mock.lockGetString.Unlock()
	if mock.GetStringFunc == nil {
		var (
			sOut string
		)
		return sOut
	}
	return mock.GetStringFunc(key, defaultValue...)
}

// GetStringCalls gets all the calls that were made to GetString.
// Check the length with:
//
//	len(mockedConf.GetStringCalls())
func (mock *ConfMock) GetStringCalls() []struct {
	Key          string
	DefaultValue []string
} {
	var calls []struct {
		Key          string
		DefaultValue []string
	}
	mock.lockGetString.RLock()
	calls = mock.calls.GetString
	mock.lockGetString.RUnlock()
	return calls
}

// Unmarshal calls UnmarshalFunc.
func (mock *ConfMock) Unmarshal(key string, config any, defaultValue ...any) error {
	callInfo := struct {
		Key          string
		Config       any
		DefaultValue []any
	}{
		Key:          key,
		Config:       config,
		DefaultValue: defaultValue,
	}
	mock.lockUnmarshal.Lock()
	mock.calls.Unmarshal = append(mock.calls.Unmarshal, callInfo)
	mock.lockUnmarshal.Unlock()
	if mock.UnmarshalFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UnmarshalFunc(key, config, defaultValue...)
}

// UnmarshalCalls gets all the calls that were made to Unmarshal.
// Check the length with:
//
//	len(mockedConf.UnmarshalCalls())
func (mock *ConfMock) UnmarshalCalls() []struct {
	Key          string
	Config       any
	DefaultValue []any
} {
	var calls []struct {
		Key          string
		Config       any
		DefaultValue []any
	}
	mock.lockUnmarshal.RLock()
	calls = mock.calls.Unmarshal
	mock.lockUnmarshal.RUnlock()
	return calls
}
